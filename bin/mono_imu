#!/usr/bin/env python
import os
import sys
import re

from pathlib import Path
from functools import reduce


def yield_success(matches):
    matches = [match for match in matches if match is not None]
    return matches[0] if len(matches) > 0 else None


def parse_nodename(argv):
    matches = [re.match(r"__name\s*:=\s*(?P<name>.+)", arg) for arg in argv]
    match = yield_success(matches)
    return (
        match.group("name") if match else None,
        [arg for (arg, match) in zip(argv, matches) if match is None],
    )


def hijack_nodename_argv(argv):
    argv_original = [arg for arg in argv]
    nodename_original, argv_else = parse_nodename(argv_original[1:])
    argv_new_nodename = (
        []
        if nodename_original is None
        else ["__name:={}".format(nodename_original + "__launcher")]
    )

    argv_nodename_hijacked = argv_original[0:1] + argv_new_nodename + argv_else
    return argv_original, argv_nodename_hijacked


argv_original, argv_hijacked = hijack_nodename_argv(sys.argv)
sys.argv = argv_hijacked

import rospy
import docker


def maybe_get_namespace():
    if "ROS_NAMESPACE" in os.environ:
        return os.environ["ROS_NAMESPACE"]
    return None


def get_rosparam_of_string_list(name, pattern=None):
    def log_failure(reason):
        rospy.logerr("Parameter {} should be provided {}".format(name, reason))

    if not rospy.has_param(name):
        return None

    value = rospy.get_param(name)
    if not isinstance(value, list):
        log_failure("as a list of string")
        rospy.logerr("Instead got: {}".format(type(value)))
        return None

    elements_type = reduce(lambda x, y: x | {y}, map(type, value), set())

    if elements_type != {str}:
        log_failure("as a list of string")
        rospy.logerr("Instead got: {}".format(elements_type))
        return None

    if pattern is None:
        return value

    for element in value:
        if not re.match(pattern, element):
            log_failure("following a regular expression {}".format(pattern))
            rospy.logerr("Instead got an element: {}".format(element))
            return None

    return value


def touch_files():
    touchs = get_rosparam_of_string_list("~touchs")
    if touchs is None:
        return

    for touch in touchs:
        file = Path(touch)
        file.touch(exist_ok=True)


def get_mounts():
    mounts = get_rosparam_of_string_list(
        "~mounts", r"\s*[^(\0|:)]+\s*:\s*[^(\0|:)]+(\s*:\s*(rw|ro)\s*)?"
    )
    if mounts is None:
        return None

    def make_mount_volume(mount_repr):
        splits = [split.strip() for split in mount_repr.split(":")]
        host_path = splits[0]
        container_path = splits[1]

        if len(splits) == 2:
            mount_mode = "rw"
        else:
            mount_mode = splits[2]

        return host_path, {"bind": container_path, "mode": mount_mode}

    return dict([make_mount_volume(mount) for mount in mounts])


def parse_log_path(argv):
    matches = [re.match(r"__log\s*:=\s*(?P<log>.+)", arg) for arg in argv]
    match = yield_success(matches)
    return (
        match.group("log") if match else None,
        [arg for (arg, match) in zip(argv, matches) if match is None],
    )


def make_container_argv(argv):
    _, argv = parse_log_path(argv[1:])
    return argv


def run_container(client, namespace, argv, mounts):
    image = "orbslam3-docker-app"
    binpath = "/catkin_ws/orbslam3_docker_ros/mono_imu__containerized"
    return client.containers.run(
        image,
        command=[binpath] + argv,
        auto_remove=True,
        network="host",
        volumes=mounts,
        environment={} if namespace is None else {"ROS_NAMESPACE": namespace},
        detach=True,
        init=True,
    )


def shutdown(container):
    container.stop(timeout=5)


def main():
    rospy.init_node("mono_imu")

    namespace = maybe_get_namespace()
    argv = make_container_argv(argv_original)

    touch_files()
    mounts = get_mounts()
    rospy.loginfo("mounts: {}".format(mounts))

    client = docker.from_env()
    container = run_container(client, namespace, argv, mounts)
    logs = container.logs(stream=True, follow=True)

    rospy.on_shutdown(lambda: shutdown(container))
    for log in logs:
        rospy.loginfo(log.strip())


if __name__ == "__main__":
    main()
